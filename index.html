<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Halftone</title>

        <!-- Bootstrap -->
        <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css" rel="stylesheet">
        <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">
        <link href="//maxcdn.bootstrapcdn.com/bootswatch/3.2.0/darkly/bootstrap.min.css" rel="stylesheet">
        <link href="style.css" rel="stylesheet">
        <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
        <!-- Include all compiled plugins (below), or include individual files as needed -->
        <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>
        <script type="text/javascript">
            $(document).ready(function() {
                function update() {
                    console.log("update");
                    canvas.width = image.width;
                    canvas.height = image.height;
                    ctx.drawImage(image, 0, 0);
                    //console.log(ctx.getImageData(0, 0, canvas.width, canvas.height));
                    
                    var rows = rowInput.value;
                    var cols = colInput.value;
                    var minSize = minInput.value;
                    var maxSize = maxInput.value;
                    var spacing = spacingInput.value;
                    var row;
                    var col;
                    var scale;
                    var imageAspect = canvas.width/canvas.height;
                    var waAspect = cols/rows;
                    if(waAspect<imageAspect){
                        scale = rows/image.height;
                    }else{
                        scale = cols/image.width;
                    }
                    var waCanvas = downScaleCanvas(canvas,scale);
                    var waData = waCanvas.getContext('2d').getImageData(0,0,cols,rows);
                    canvas.width = cols * spacing;
                    canvas.height = rows * spacing;
                    var val;
                    var minVal = 9999999;
                    var maxVal = 0;
                    var vals = new Array();
                    for (row = 0; row < rows; row++) {
                        for (col = 0; col < cols; col++) {
                            val = waData.data[(row*cols+col)*4]+waData.data[(row*cols+col)*4+1]+waData.data[(row*cols+col)*4+2];
                            vals.push(val);
                            minVal = Math.min(minVal,val);
                            maxVal = Math.max(maxVal,val);
                        }
                    }
                    var currentDR = (maxVal - minVal)/765;
                    var wantedDR = (maxSize - minSize)/spacing;
                    var multiplier = wantedDR/currentDR;
                    var brightness = minSize-(minVal/765) *spacing*multiplier;
                    var x;
                    var y;
                    var radius;
                    //console.log(minVal,maxVal,multiplier);
                    minVal = 9999999;
                    maxVal = 0;
                    gcodeOutput.html('\
(Generated by html5 cnc halftonepattern generator)\n\
(XYZ in millimeters, absolute)\n\
G21 G90 G64 G40\n\
G0 Z3.0\n\
G17\n\
M3 S255\n\
');
                    for (row = 0; row < rows; row++) {
                        ctx.fillStyle = '#FFFFFF';
                        for (col = 0; col < cols; col++) {
                            scale = (vals[row*cols+col]/765) *spacing*multiplier+brightness;
                            x = col * spacing + spacing / 2;
                            y = row * spacing + spacing / 2;
                            radius = scale/2;
                            ctx.beginPath();
                            ctx.arc(x,y,radius , 0, 2 * Math.PI);
                            ctx.fill();
                            //gcodeOutput.append('G0 X'+x+' Y'+y+'\n');
                            gcodeOutput.append('G1 X'+x+' Y'+(y-radius-minSize).toFixed(2)+'\n');
                            gcodeOutput.append('G2 X'+x+' Y'+(y-radius-minSize).toFixed(2)+' I'+x+' J'+y+'\n');
                        }
                    }
                    gcodeOutput.append('\
M5');
                }
                function downScaleCanvas(cv, scale) { //http://stackoverflow.com/questions/18922880/html5-canvas-resize-downscale-image-high-quality
                    if (!(scale < 1) || !(scale > 0))
                        throw ('scale must be a positive number <1 ');
                    var sqScale = scale * scale; // square scale = area of source pixel within target
                    var sw = cv.width; // source image width
                    var sh = cv.height; // source image height
                    var tw = Math.ceil(sw * scale); // target image width
                    var th = Math.ceil(sh * scale); // target image height
                    var sx = 0, sy = 0, sIndex = 0; // source x,y, index within source array
                    var tx = 0, ty = 0, yIndex = 0, tIndex = 0; // target x,y, x,y index within target array
                    var tX = 0, tY = 0; // rounded tx, ty
                    var w = 0, nw = 0, wx = 0, nwx = 0, wy = 0, nwy = 0; // weight / next weight x / y
                    // weight is weight of current source point within target.
                    // next weight is weight of current source point within next target's point.
                    var crossX = false; // does scaled px cross its current px right border ?
                    var crossY = false; // does scaled px cross its current px bottom border ?
                    var sBuffer = cv.getContext('2d').
                            getImageData(0, 0, sw, sh).data; // source buffer 8 bit rgba
                    var tBuffer = new Float32Array(3 * sw * sh); // target buffer Float32 rgb
                    var sR = 0, sG = 0, sB = 0; // source's current point r,g,b
                    /* untested !
                     var sA = 0;  //source alpha  */

                    for (sy = 0; sy < sh; sy++) {
                        ty = sy * scale; // y src position within target
                        tY = 0 | ty;     // rounded : target pixel's y
                        yIndex = 3 * tY * tw;  // line index within target array
                        crossY = (tY != (0 | ty + scale));
                        if (crossY) { // if pixel is crossing botton target pixel
                            wy = (tY + 1 - ty); // weight of point within target pixel
                            nwy = (ty + scale - tY - 1); // ... within y+1 target pixel
                        }
                        for (sx = 0; sx < sw; sx++, sIndex += 4) {
                            tx = sx * scale; // x src position within target
                            tX = 0 | tx;    // rounded : target pixel's x
                            tIndex = yIndex + tX * 3; // target pixel index within target array
                            crossX = (tX != (0 | tx + scale));
                            if (crossX) { // if pixel is crossing target pixel's right
                                wx = (tX + 1 - tx); // weight of point within target pixel
                                nwx = (tx + scale - tX - 1); // ... within x+1 target pixel
                            }
                            sR = sBuffer[sIndex    ];   // retrieving r,g,b for curr src px.
                            sG = sBuffer[sIndex + 1];
                            sB = sBuffer[sIndex + 2];

                            /* !! untested : handling alpha !!
                             sA = sBuffer[sIndex + 3];
                             if (!sA) continue;
                             if (sA != 0xFF) {
                             sR = (sR * sA) >> 8;  // or use /256 instead ??
                             sG = (sG * sA) >> 8;
                             sB = (sB * sA) >> 8;
                             }
                             */
                            if (!crossX && !crossY) { // pixel does not cross
                                // just add components weighted by squared scale.
                                tBuffer[tIndex    ] += sR * sqScale;
                                tBuffer[tIndex + 1] += sG * sqScale;
                                tBuffer[tIndex + 2] += sB * sqScale;
                            } else if (crossX && !crossY) { // cross on X only
                                w = wx * scale;
                                // add weighted component for current px
                                tBuffer[tIndex    ] += sR * w;
                                tBuffer[tIndex + 1] += sG * w;
                                tBuffer[tIndex + 2] += sB * w;
                                // add weighted component for next (tX+1) px                
                                nw = nwx * scale
                                tBuffer[tIndex + 3] += sR * nw;
                                tBuffer[tIndex + 4] += sG * nw;
                                tBuffer[tIndex + 5] += sB * nw;
                            } else if (crossY && !crossX) { // cross on Y only
                                w = wy * scale;
                                // add weighted component for current px
                                tBuffer[tIndex    ] += sR * w;
                                tBuffer[tIndex + 1] += sG * w;
                                tBuffer[tIndex + 2] += sB * w;
                                // add weighted component for next (tY+1) px                
                                nw = nwy * scale
                                tBuffer[tIndex + 3 * tw    ] += sR * nw;
                                tBuffer[tIndex + 3 * tw + 1] += sG * nw;
                                tBuffer[tIndex + 3 * tw + 2] += sB * nw;
                            } else { // crosses both x and y : four target points involved
                                // add weighted component for current px
                                w = wx * wy;
                                tBuffer[tIndex    ] += sR * w;
                                tBuffer[tIndex + 1] += sG * w;
                                tBuffer[tIndex + 2] += sB * w;
                                // for tX + 1; tY px
                                nw = nwx * wy;
                                tBuffer[tIndex + 3] += sR * nw;
                                tBuffer[tIndex + 4] += sG * nw;
                                tBuffer[tIndex + 5] += sB * nw;
                                // for tX ; tY + 1 px
                                nw = wx * nwy;
                                tBuffer[tIndex + 3 * tw    ] += sR * nw;
                                tBuffer[tIndex + 3 * tw + 1] += sG * nw;
                                tBuffer[tIndex + 3 * tw + 2] += sB * nw;
                                // for tX + 1 ; tY +1 px
                                nw = nwx * nwy;
                                tBuffer[tIndex + 3 * tw + 3] += sR * nw;
                                tBuffer[tIndex + 3 * tw + 4] += sG * nw;
                                tBuffer[tIndex + 3 * tw + 5] += sB * nw;
                            }
                        } // end for sx 
                    } // end for sy

                    // create result canvas
                    var resCV = document.createElement('canvas');
                    resCV.width = tw;
                    resCV.height = th;
                    var resCtx = resCV.getContext('2d');
                    var imgRes = resCtx.getImageData(0, 0, tw, th);
                    var tByteBuffer = imgRes.data;
                    // convert float32 array into a UInt8Clamped Array
                    var pxIndex = 0; //  
                    var val;
                    for (sIndex = 0, tIndex = 0; pxIndex < tw * th; sIndex += 3, tIndex += 4, pxIndex++) {
                        tByteBuffer[tIndex] = Math.ceil(tBuffer[sIndex]);
                        tByteBuffer[tIndex + 1] = Math.ceil(tBuffer[sIndex + 1]);
                        tByteBuffer[tIndex + 2] = Math.ceil(tBuffer[sIndex + 2]);
                        tByteBuffer[tIndex + 3] = 255;
                    }
                    // writing result to canvas.
                    resCtx.putImageData(imgRes, 0, 0);
                    return resCV;
                }
                var reader = new FileReader();
                var image = new Image();
                var canvas = $("#canvas").get(0);
                var rowInput = $("#waRows").get(0);
                var colInput = $("#waColumns").get(0);
                var spacingInput = $("#waSpacing").get(0);
                var minInput = $("#waMin").get(0);
                var maxInput = $("#waMax").get(0);
                var gcodeOutput = $("#gcode");
                var ctx = canvas.getContext("2d");
                reader.onload = function(e) {
                    console.log(e.target.result);
                    image.src=e.target.result;
                }
                $('#fileInput').bind('change', function(e) {
                    reader.readAsDataURL(this.files[0]);
                })
                $("#waRows").bind('change', update);
                $("#waColumns").bind('change', update);
                $("#waSpacing").bind('change', update);
                $("#waMin").bind('change', update);
                $("#waMax").bind('change', update);
                $(image).bind('load',update);
                image.src = "dorks.jpg";

            });
        </script>

        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
          <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
          <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
        <![endif]-->
    </head>
    <body>
            <h1 class="col-xs-12">Halftone pattern</h1>
            <div class="col-xs-2">
            <!--            <img id="filePreview" src="dorks.jpg" class="img-responsive col-xs-12"/>-->
            <h2>Settings</h2>
            <form class="form" role="form">
                <!--                <div class="form-group">
                                    <label class="" for="waWidth">Width</label>
                                    <input type="number" class="form-control" id="waWidth" value="800">
                                </div>
                                <div class="form-group">
                                    <label class="" for="waHeight">Height</label>
                                    <input type="number" class="form-control" id="waHeight" value="400">
                                </div>-->
                <span class="btn btn-default btn-file">
                    Select image <input type="file" id="fileInput">
                </span>
                <div class="form-group">
                    <label class="" for="waRows">Rows</label>
                    <input type="number" class="form-control" id="waRows" value="30">
                </div>
                <div class="form-group">
                    <label class="" for="waColumns">Columns</label>
                    <input type="number" class="form-control" id="waColumns" value="50">
                </div>
                <div class="form-group">
                    <label class="" for="waSpacing">Spacing</label>
                    <input type="number" class="form-control" id="waSpacing" value="20">
                </div>
                <div class="form-group">
                    <label class="" for="waMin">Smallest</label>
                    <input type="number" class="form-control" id="waMin" value="4">
                </div>
                <div class="form-group">
                    <label class="" for="waMax">Biggest</label>
                    <input type="number" class="form-control" id="waMax" value="16">
                </div>
            </form>
        </div>
        <div class="col-xs-6">
            <h2>Preview</h2>
            <canvas id="canvas" class="img-responsive">
            </canvas>
        </div>
        <div class="col-xs-4">
            <h2>Gcode</h2>
            <textarea id="gcode" class="col-xs-12" cols="20" ></textarea>
        </div>
        <footer class="col-xs-12">
            <small>Lucas Granberg 2014</small>
        </footer>

    </body>
</html>
